# 95. 费解的开关

你玩过“拉灯”游戏吗？

2525 盏灯排成一个 5×55×5 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 n�，代表数据中共有 n� 个待解决的游戏初始状态。

以下若干行数据分为 n� 组，每组数据有 55 行，每行 55 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 n� 行数据，每行有一个小于等于 66 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出 −1−1。

#### 数据范围

0<n≤5000<�≤500

#### 输入样例：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

输出样例：

```
3
2
-1
```
# 题解(法1：由第n行的0/1状态来确定第n+1行的操作)
```c++
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

char g[10][10];

const int INF = 1000000;

int dx[5] = {0, -1, 0, 1, 0}, dy[5] = {0, 0, 1, 0, -1};

void turn(int x, int y) { // 辅助函数，用于改变灯的状态
	for (int i = 0; i < 5; i ++ ) {
		int a = x + dx[i], b = y + dy[i];
		if (a >= 0 && a < 5 && b >= 0 && b < 5) { // 判断是否处于范围内

			// 改变g[a][b]上的数，交换0/1
			g[a][b] = '0' + ('1' - g[a][b]); // 只是一个表达式，作用在于交换
			// 或者使用异或 g[a][b] ^= 1;
		}
	}
}

int work() {
	int ans = INF;
	for (int k = 0; k < 1 << 5; k ++ ) { // 这里k < 32.因为每一行有2 ^ 5 = 32种可能的情况

		int res = 0; // 当前方案的操作数
		// 备份
		char backup[10][10];
		memcpy(backup, g, sizeof g); // 人话：将二维数组‘g’的内容复制到另一个二维数组‘backup’中

		// 处理第1行
		for (int j = 0; j < 5; j ++ ) {
			if (k >> j & 1) { // 位运算操作，用于检验k的第j为是否为1

				// 如果判断到这一行的第j位的数是1，则执行按按钮操作
				res ++; // 操作数加1
				turn(0, j);
			}
		}

		// 递推后4行
		for (int i = 0; i < 4; i ++ )
			for (int j = 0; j < 5; j ++ )
				if (g[i][j] == '0') {
					res ++;
					turn (i + 1, j);
				}
		bool is_successful = true;
		for (int j = 0; j < 5; j ++ )
			if (g[4][j] == '0') {
				is_successful = false;
				break;
			}
		if (is_successful)
			ans = min(ans, res);

		// 恢复原状态
		memcpy(g, backup, sizeof g);
	}
	if (ans > 6)
		ans = -1;
	return ans;
}

int main() {
	int T;
	cin >> T;
	while (T --) {
		for (int i = 0; i < 5; i ++ )
			cin >> g[i];
		cout << work() << endl;
	}
	return 0;
}
```